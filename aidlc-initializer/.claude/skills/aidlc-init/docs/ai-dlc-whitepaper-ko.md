# AI 주도 개발 라이프사이클(AI-DLC) 방법론 정의

**저자:** Raja SP, Amazon Web Services

---

## I. 배경

소프트웨어 엔지니어링의 진화는 개발자가 저수준의 차별화되지 않은 작업을 추상화하여 복잡한 문제 해결에 집중할 수 있도록 하는 지속적인 탐구였습니다. 초기 기계어에서 고급 프로그래밍 언어, API 및 라이브러리 채택에 이르기까지 각 단계는 개발자 생산성을 크게 향상시켰습니다. 현재 대규모 언어 모델의 통합은 코드 생성, 버그 탐지, 테스트 생성 등의 작업에 대화형 자연어 상호작용을 도입하여 소프트웨어 생성 방식에 혁명을 일으키고 있습니다. 이것은 AI 보조 시대의 시작이며, AI가 이러한 세밀하고 특정한 작업을 강화하고 있습니다.

AI가 진화함에 따라 그 적용은 코드 생성을 넘어 요구사항 상세화, 계획, 작업 분해, 설계, 개발자와의 실시간 협업으로까지 확장되고 있습니다. 이러한 변화는 AI 주도 시대의 시작을 알리며, AI가 개발 프로세스를 적극적으로 조정합니다. 그러나 기존 소프트웨어 개발 방법론은 인간 주도의 장기 프로세스를 위해 설계되었으며, AI의 속도, 유연성, 고급 기능(예: 에이전트형)과 완전히 일치하지 않습니다. 수동 워크플로와 경직된 역할 정의에 대한 의존은 AI를 충분히 활용하는 능력을 제한합니다. AI를 이러한 방법론에 후추가하는 것은 그 잠재력을 제한할 뿐만 아니라 시대착오적인 비효율성을 강화하기도 합니다. AI의 변혁적 힘을 최대한 활용하려면 SDLC 방법을 재고해야 합니다. 이 재고에는 AI를 중심 협력자로 위치시키고, 더 빠른 의사결정, 원활한 작업 실행, 지속적인 적응성을 가능하게 하도록 워크플로, 역할, 반복을 조정하는 것이 필요합니다.

본 백서에서는 AI의 기능을 완전히 통합하도록 설계된 재고된 AI 네이티브 방법론인 AI 주도 개발 라이프사이클(AI-DLC)을 소개하고 정의합니다. 이는 소프트웨어 엔지니어링의 다음 진화를 위한 기초를 마련합니다.

---

## II. 핵심 원칙

이 섹션의 원칙들은 AI-DLC를 정의하기 위한 기반을 형성하며, 그 단계, 역할, 산출물, 의식을 형성합니다. 이러한 전제들은 제안된 방법론을 검증하는 데 중요하며, 그 설계 뒤의 기본적인 이론적 근거를 제공합니다.

### 1. 후추가가 아닌 재고

기존 SDLC나 애자일(예: 스크럼) 같은 방법론을 유지하면서 AI를 후추가하는 대신, 개발 방법론을 재고하기로 선택합니다. 이러한 전통적 방법론은 더 긴 반복 기간(월이나 주 단위)을 위해 구축되었으며, 데일리 스탠드업이나 회고와 같은 의식으로 이어졌습니다. 대조적으로 AI의 적절한 적용은 시간이나 일 단위로 측정되는 급속한 사이클로 이어집니다. 이는 지속적인 실시간 검증과 피드백 메커니즘이 필요하며, 많은 전통적 의식의 관련성을 낮춥니다. AI가 단순, 중간, 어려운 작업 간의 경계를 감소시킬 때, 노력 추정(예: 스토리 포인트)이 중요할까요? 속도 같은 지표가 관련성이 있을까요, 아니면 비즈니스 가치 같은 지표로 대체해야 할까요? 또한 AI는 계획, 작업 분해, 요구사항 분석, 설계 기술 적용(예: 도메인 모델링) 같은 수동 관행을 자동화하는 방향으로 진화하고 있으며, 의도에서 코드로의 전환에 필요한 단계 수를 줄입니다. 이러한 새로운 역학은 후추가가 아닌 제1원칙 사고에 기반한 재고를 요구합니다. 우리에게 필요한 것은 더 빠른 마차가 아니라 자동차입니다.

### 2. 대화 방향의 역전

AI-DLC는 인간이 AI와 대화를 시작하여 작업을 완료하는 것이 아니라, **AI가 인간과의 대화를 시작하고 지시하는** 근본적인 전환을 가져옵니다. AI는 고수준 의도(예: 새로운 비즈니스 기능 구현)를 실행 가능한 작업으로 분해하고, 권장사항을 생성하며, 트레이드오프를 제안함으로써 워크플로를 주도합니다. 인간은 승인자로 기능하며, 중요한 분기점에서 선택지를 검증, 선택, 확인합니다. 이 AI 주도 접근방식은 개발자가 고가치 의사결정에 집중할 수 있게 하며, AI는 계획, 작업 분해, 자동화를 처리합니다. 전통적 역학을 역전시킴으로써 AI-DLC는 인간의 참여가 목적을 갖고 감독, 위험 완화, 전략적 정렬에 집중되도록 보장하여 속도와 품질을 모두 향상시킵니다. 이를 설명하는 비유는 Google Maps입니다: 인간은 목적지(의도)를 설정하고, 시스템은 단계별 지시(AI의 작업 분해 및 권장사항)를 제공합니다. 도중에 인간은 필요에 따라 감독하고 여정을 조정합니다.

### 3. 설계 기술을 핵심으로 통합

스크럼이나 칸반 같은 애자일 프레임워크는 설계 기술(예: 도메인 주도 설계)을 범위 밖으로 두고 팀에게 자체 선택을 권장합니다. 이는 전반적인 소프트웨어 품질 저하로 이어지는 중요한 공백을 만들었습니다. 미국만 해도 소프트웨어 품질 문제로 2022년에 2.41조 달러의 비용이 발생한 것으로 추정됩니다. 설계 기술을 분리하는 대신, AI-DLC는 이를 필수 핵심으로 가집니다. 도메인 주도 설계(DDD), 행동 주도 개발(BDD), 테스트 주도 개발(TDD)을 각각 채택하는 팀을 위해 AI-DLC에는 다른 변형이 존재합니다. 본 백서에서는 AI-DLC의 DDD 변형을 논의하며, 시스템을 독립적이고 적절한 크기의 경계 컨텍스트로 분해하기 위해 DDD 원칙을 사용하여 병렬로 빠르게 구축할 수 있도록 합니다. AI는 계획과 작업 분해 과정에서 이러한 기술을 본질적으로 적용하며, 개발자에게는 검증과 조정만 요구합니다. 이 통합은 시간 또는 일 단위 반복 사이클을 가능하게 하며, 수동 중노동을 제거하면서 소프트웨어 품질을 유지하는("더 나은 시스템을 더 빠르게 구축") 핵심입니다.

### 4. AI 능력과 정렬

본 백서는 AI의 미래 잠재력에 대해 낙관적이지만 현재 상태에 대해 완전히 현실적입니다. AI-DLC는 현재 AI가 진보했지만, 고수준 의도를 실행 가능한 코드로 자율적으로 변환하거나 해석 가능성과 안전성을 보장하면서 인간 감독 없이 독립적으로 운영할 신뢰성이 아직 없다는 것을 인식합니다. 동시에 개발자가 대부분의 지적 중노동을 수행하고 AI가 단순히 증강을 제공하는 AI 보조 패러다임은 개발에서 AI의 잠재력을 완전히 해방시키지 못합니다. AI-DLC는 인간 참여와 현재 AI의 능력 및 한계의 균형을 맞추는 AI 주도 패러다임을 채택합니다. 이 안에서 개발자는 검증, 의사결정, 감독의 최종 책임을 보유합니다. 이 균형은 개발자 판단이 제공하는 중요한 안전장치를 손상시키지 않으면서 AI의 강점이 효과적으로 활용되도록 보장합니다.

### 5. 복잡한 시스템 구축 지원

AI-DLC는 지속적인 기능 적응성, 고급 아키텍처 복잡성, 다수의 트레이드오프 관리, 확장성, 통합 및 커스터마이징 요구사항을 요구하는 시스템 구축에 대응합니다. 이들은 고급 설계 기술, 패턴, 모범 사례의 적용을 필요로 하며, 일반적으로 대규모 및/또는 규제된 조직 내에서 여러 팀이 결속하여 작업하는 것을 수반합니다. 트레이드오프 관리가 거의 또는 전혀 필요하지 않고 비개발자 페르소나가 개발할 수 있는 더 단순한 시스템은 AI-DLC의 범위 밖이며 로우코드/노코드 접근방식에 적합합니다.

### 6. 인간 공생을 강화하는 요소 유지

방법론을 재고할 때 인간 검증과 위험 완화에 필수적인 기존 방법론의 산출물과 터치포인트를 유지합니다. 예를 들어 사용자 스토리는 무엇을 구축해야 하는지에 대한 인간과 AI의 이해를 정렬시키고 명확하게 정의된 계약으로 기능합니다. 재고된 방법론에서도 사용자 스토리를 유지합니다. 또 다른 예는 AI가 생성한 계획과 코드가 조직의 위험 프레임워크를 준수하도록 보장하는 위험 레지스터입니다. 이러한 유지된 요소는 정렬성이나 안전성을 손상시키지 않으면서 빠른 반복을 가능하게 하기 위해 실시간 사용에 최적화됩니다.

### 7. 친숙함을 통한 전환 촉진

새로운 방법론은 광범위한 훈련을 요구하지 않아야 하며, 기존 실무자는 하루 만에 오리엔테이션을 받고 실습을 시작할 수 있어야 합니다. 연상 학습을 통한 쉬운 채택을 지원하기 위해 AI-DLC는 구 방법론의 친숙한 용어 간 기본 관계를 유지하면서 현대화된 용어를 도입합니다. 예를 들어 스크럼의 스프린트는 구축과 검증을 위한 반복 사이클을 나타냅니다. 그러나 스프린트는 일반적으로 AI 이전 시대에서 4-6주 길이였습니다. AI-DLC에서 반복 사이클은 지속적이며 시간 또는 일 단위입니다. 따라서 스프린트를 의도적으로 이름을 바꿀 필요가 있습니다. AI-DLC는 스프린트를 **볼트(Bolts)**로 재브랜딩하여 전례 없는 속도를 제공하는 빠르고 집중적인 사이클을 강조합니다.

### 8. 효율성을 위한 책임 간소화

AI의 작업 분해 및 의사결정 능력을 활용함으로써 개발자는 인프라, 프론트엔드, 백엔드, DevOps, 보안 등의 전통적 전문화 사일로를 초월하는 힘을 얻습니다. 이러한 책임의 수렴은 여러 전문 역할의 필요성을 줄이고 개발 프로세스를 간소화합니다. 그러나 제품 소유자와 개발자는 프레임워크에 필수적이며, 감독, 검증, 전략적 의사결정을 위한 중요한 책임을 보유합니다. 이러한 역할은 비즈니스 목표와의 정렬을 보장하고, 설계 품질을 유지하며, 위험 관리 프레임워크에의 준수를 유지하고, 자동화와 인간 책임성의 균형을 유지합니다. 방법론 정의에서 제1원칙을 고수하고 역할을 최소한으로 유지하며, 추가 역할은 중요하게 필요한 경우에만 도입합니다.

### 9. 단계 최소화, 흐름 최대화

자동화와 책임 수렴을 통해 AI-DLC는 인수인계와 전환을 최소화하고 지속적인 반복 흐름을 가능하게 하는 것을 목표로 합니다. 그러나 AI가 생성한 코드가 경화("빠른 시멘트")되지 않고 미래 반복을 위해 적응 가능하도록 보장하기 위해 인간 검증과 의사결정은 여전히 중요합니다. 이를 해결하기 위해 AI-DLC는 중요한 결정 분기점에서의 인간 감독을 위해 특별히 설계된 최소한이지만 충분한 수의 단계를 통합합니다. 이러한 검증은 낭비되는 하류 노력이 발생하기 전에 식별하고 제거하는 "손실 함수" 형태로 기능합니다.

### 10. 하드와이어된 독단적 SDLC 워크플로 없음

AI-DLC는 다른 개발 경로(새 시스템 개발, 리팩토링, 결함 수정, 마이크로서비스 확장 등)에 대해 독단적 워크플로를 규정하는 것을 피합니다. 대신 AI가 주어진 경로의 의도에 기반하여 레벨 1 계획을 권장하는 진정한 AI 우선 접근방식을 채택합니다. 인간은 AI와의 대화형 대화를 통해 이러한 AI 생성 계획을 검증하고 조정하며, 이 프로세스를 레벨 2(서브태스크) 및 후속 계층 레벨을 통해 계속합니다. 작업 실행 레벨에서 AI가 작업을 구현하고 인간은 결과 검증을 통해 감독을 유지합니다. 이 유연한 접근방식은 방법론이 적응 가능하며 중요한 결정에 대한 인간 제어를 유지하면서 AI 능력과 함께 진화할 수 있도록 합니다.

---

## III. 핵심 프레임워크

이 섹션에서는 AI-DLC의 핵심 프레임워크 개요를 설명하며, 그 단계, 역할, 워크플로, 주요 산출물을 상세히 설명합니다.

### 1. 산출물 (Artifacts)

#### 의도 (Intent)
AI-DLC에서 비즈니스 목표, 기능 또는 기술적 성과(예: 성능 확장) 등 달성해야 할 것을 캡슐화한 고수준 목적 선언입니다. 이는 AI 주도 분해의 출발점으로 기능하며, 실행 가능한 작업으로 분해되어 인간의 목표와 AI 생성 계획을 정렬시킵니다.

#### 유닛 (Unit)
의도에서 파생된 결속력 있는 자기완결형 작업 요소를 나타내며, 측정 가능한 가치를 제공하도록 특별히 설계되었습니다. 예를 들어 비즈니스 아이디어를 구현하기 위한 의도는 DDD의 서브도메인이나 스크럼의 에픽과 유사한 독립적 기능 블록을 나타내는 유닛으로 분해될 수 있습니다. 각 유닛은 그 기능적 범위를 명확히 표현하는 작업(이 경우 사용자 스토리) 세트를 포함합니다. AI-DLC의 맥락에서 의도를 유닛으로 분해하는 프로세스는 AI가 주도하며, 개발자 및/또는 제품 소유자가 결과 유닛을 검증하고 비즈니스 및 기술 목표와의 정렬을 보장하기 위해 세련화합니다. 유닛은 느슨하게 결합되어 하류에서 자율적 개발과 독립적 배포를 가능하게 합니다.

#### 볼트 (Bolt)
AI-DLC에서 최소 반복이며, 유닛 또는 유닛 내 작업 세트의 빠른 구현을 위해 설계되었습니다. 볼트(스크럼의 스프린트와 유사)는 주 단위가 아닌 **시간 또는 일 단위**로 측정되는 구축-검증 사이클로, 집중적 초점과 고속도 전달을 강조합니다. 각 볼트는 명확히 정의된 작업 범위(예: 유닛 내 사용자 스토리 컬렉션)를 캡슐화하며, 지원하는 유닛의 전체 목표와의 정렬을 유지하면서 점진적 진행을 가능하게 합니다. 유닛은 하나 이상의 볼트를 통해 실행될 수 있으며, 병렬 또는 순차적으로 실행될 수 있습니다. AI가 볼트를 계획하고 개발자/제품 소유자가 검증합니다.

#### 도메인 설계 (Domain Design)
인프라 컴포넌트와 독립적으로 유닛의 핵심 비즈니스 로직을 모델링하는 산출물입니다. AI-DLC의 첫 버전에서 AI는 도메인 주도 설계 원칙을 사용하여 집합체, 값 객체, 엔티티, 도메인 이벤트, 리포지토리, 팩토리를 포함한 전략적 및 전술적 모델링 요소를 생성합니다.

#### 논리 설계 (Logical Design)
도메인 설계를 확장하고 적절한 아키텍처 설계 패턴(예: CQRS, 서킷 브레이커 등)을 사용하여 비기능 요구사항을 충족하도록 변환합니다. AI는 개발자 검증을 위해 아키텍처 결정 기록(ADR)을 생성합니다. 논리 설계 사양을 통해 AI는 적절한 AWS 서비스와 구성을 선택함으로써 잘 설계된 원칙을 준수하는 코드와 단위 테스트를 생성합니다. 이 단계에서 AI 에이전트는 단위 테스트를 실행하고 결과를 분석하며 개발자에게 수정 권장사항을 제공합니다.

#### 배포 유닛 (Deployment Unit)
패키지화된 실행 가능 코드(예: Kubernetes 환경용 컨테이너 이미지, AWS Lambda 같은 서버리스 함수), 구성(예: Helm 차트), 인프라 컴포넌트(예: Terraform 또는 CFN 스택)를 포함하는 운영 산출물이며, 기능적 승인, 보안, NFR, 기타 위험에 대해 테스트되었습니다. AI는 모든 관련 테스트(기능 테스트, 정적 및 동적 보안 테스트, 부하 테스트 시나리오 포함)를 생성합니다. 테스트 시나리오와 케이스에 대한 인간 검증 및 조정 후, AI 에이전트는 테스트 스위트를 실행하고 결과를 분석하며 장애 지점을 코드 변경, 구성 또는 기타 종속성과 상관시킵니다. 따라서 이러한 유닛은 기능적 승인, 보안 준수, 비기능 요구사항(NFR) 준수, 운영 위험 완화에 대해 엄격히 테스트되어 원활한 배포를 위한 준비가 완료되었음을 보장합니다.

### 2. 단계와 의식 (Phases and Rituals)

#### 구상 단계 (Inception Phase)
의도를 포착하고 이를 개발을 위한 유닛으로 변환하는 데 초점을 맞춥니다. 이 단계에서는 협력적 요구사항 상세화 및 분해 의식인 **"모브 엘라보레이션(Mob Elaboration)"**을 사용합니다. 이는 퍼실리테이터가 주도하는 공유 화면이 있는 단일 룸에서 수행됩니다. 모브 엘라보레이션 중 AI는 의도를 사용자 스토리, 수용 기준, 유닛으로 초기 분해를 제안하는 중심 역할을 하며, 도메인 지식과 하류에서 빠른 병렬 실행을 위한 느슨한 결합 및 높은 응집의 원칙을 활용합니다. 제품 소유자, 개발자, QA, 기타 관련 이해관계자(모브)는 과도 설계 또는 과소 설계 부분을 조정하고 실제 제약과 정렬시킴으로써 이러한 AI 생성 산출물을 협력적으로 검토하고 세련화합니다. 이 단계의 출력에는 a) PRFAQ, b) 사용자 스토리, c) 비기능 요구사항(NFR) 정의, d) 위험 설명(조직의 위험 레지스터가 있는 경우 일치), e) 비즈니스 의도에 추적 가능한 측정 지표, f) 유닛을 구축할 수 있는 제안된 볼트를 포함한 명확히 정의된 유닛과 각각의 컴포넌트가 포함됩니다. 모브 엘라보레이션은 모브 내 및 모브와 AI 간의 깊은 정렬을 달성하면서 수주 또는 수개월의 연속 작업을 수 시간으로 압축합니다.

#### 구축 단계 (Construction Phase)
구상 단계에서 정의된 유닛을 테스트된 운영 준비 배포 유닛으로 변환하는 작업의 반복적 실행을 포함합니다. 이 단계는 AI가 기술적 고려사항과 독립적으로 비즈니스 로직을 모델링하는 도메인 설계에서, 비기능 요구사항과 적절한 클라우드 설계 패턴이 적용되는 논리 설계로 진행됩니다. AI는 논리 설계에서 상세 코드를 생성하고 컴포넌트를 적절한 AWS 서비스에 매핑하며 잘 설계된 원칙을 준수합니다. 이 단계는 기능성, 보안, 운영 준비를 보장하기 위한 자동 테스트로 마무리됩니다. 개발자는 각 단계에서 AI 생성 출력을 검증하고 중요한 결정을 내리는 데 집중하며 각 반복에서 품질과 적응성을 보장합니다. 브라운필드(기존 애플리케이션) 시나리오에서 구축 단계에는 먼저 코드를 시맨틱 리치한 모델링 표현으로 승격시켜 AI에 대한 컨텍스트를 간결하고 정확하게 만드는 것이 포함됩니다. 제안되는 모델링 표현은 정적 모델(도메인 컴포넌트, 책임, 그들의 관계만) 및 동적 모델(컴포넌트가 중요한 유스케이스를 실현하기 위해 어떻게 상호작용하는지)입니다.

AI는 이 단계 전체에서 중요한 역할을 하며, 각 작업에서 작업과 옵션(설계 패턴, 사용자 경험, 테스트 등)을 권장합니다. AI-DLC는 모브 엘라보레이션과 유사하게 모든 팀이 단일 룸에 배치되는 것을 권장합니다. 팀은 통합 사양(도메인 모델 단계에서)을 교환하고 결정을 내리며 볼트를 제공합니다. AI-DLC는 이를 **모브 구축(Mob Construction)** 의식이라고 부릅니다.

#### 운영 단계 (Operations Phase)
AI-DLC에서 운영 효율성을 위해 AI를 활용한 시스템의 배포, 관찰 가능성, 유지보수에 초점을 맞춥니다. AI는 메트릭, 로그, 트레이스를 포함한 텔레메트리 데이터를 적극적으로 분석하고, 패턴을 감지하며, 이상을 식별하고, 잠재적 SLA 위반을 예측하여 적극적인 문제 해결을 가능하게 합니다. 또한 AI는 사전 정의된 인시던트 런북과 통합하여 리소스 확장, 성능 튜닝, 장애 격리 같은 실행 가능한 권장사항을 제안하며, 개발자가 승인한 경우 솔루션을 실행합니다. 개발자는 검증자로 기능하여 AI 생성 인사이트와 제안된 액션이 SLA 및 준수 요구사항과 정렬되도록 보장합니다.

### 3. 워크플로 (Workflow)

비즈니스 의도(예: 그린필드 개발, 브라운필드 강화, 현대화, 결함 수정)가 주어지면, AI-DLC는 AI에게 의도를 구현하기 위한 워크플로를 개요하는 레벨 1 계획을 생성하도록 촉구하는 것으로 시작합니다. 이 계획은 초기 제안으로 기능하며, 그 후 비즈니스 목표와 엔지니어링 제약과의 정렬을 보장하기 위해 인간에 의해 투명하게 검토, 검증, 세련화됩니다. 

AI-DLC의 핵심에는 각 단계의 산출물을 다음 단계를 위한 시맨틱 리치한 컨텍스트로 변환하기 위해 인간 감독을 단계적으로 적용하는 원칙이 있습니다. 각 단계는 전략적 결정 지점으로 기능하며, 인간 감독이 손실 함수처럼 작동하여 오류가 하류로 눈덩이처럼 불어나기 전에 조기에 포착하고 수정합니다. 이는 재귀적으로 반복됩니다. 레벨 1 계획의 각 단계는 AI에 의해 더 세밀한 실행 가능한 서브태스크로 분해되며, 다시 인간 감독 하에 정확성과 맥락적 적절성을 보장합니다.

생성된 모든 산출물(의도, 사용자 스토리, 도메인 모델, 테스트 계획)은 보존되어 라이프사이클 전체에서 AI가 참조하는 **"컨텍스트 메모리"**로 기능합니다. 전통적 SDLC 방법론과 유사하게 AI-DLC는 본질적으로 반복적이며 지속적인 세련화와 적응을 가능하게 합니다. 또한 모든 산출물은 연결되어 있어 후방 및 전방 추적성(예: 도메인 모델 요소를 특정 사용자 스토리에 연결)을 가능하게 하며, AI가 각 단계에서 정확하고 가장 관련성 높은 컨텍스트를 획득하도록 보장합니다. 프로세스 전체에서 AI는 전략적 계획, 작업 분해, 생성 등을 실행하고, 인간은 감독과 검증을 제공합니다.

---

## IV. AI-DLC 실습: 그린필드 개발

제품 소유자가 "제품 크로스셀링을 위한 추천 엔진 개발" 같은 고수준 의도를 표명하는 것으로 프로세스를 시작하는 시나리오를 고려합니다. AI는 이를 새 애플리케이션을 구축하는 의도로 인식하고 위 섹션의 워크플로 단계와 같은 레벨 1 계획을 생성합니다. 팀은 검증, 확인하고 레벨 1 계획의 단계를 추가/수정합니다. 최종 레벨 1 계획으로 AI는 구상 단계로 진행합니다.

### 1. 구상 단계

다음 항목들은 모브 엘라보레이션 의식에서의 주요 대화를 개요합니다:

a. AI는 명확화를 위한 질문을 합니다(예: "주요 사용자는 누구인가요? 이 시스템이 달성해야 할 주요 비즈니스 성과는 무엇인가요?"), 목표에 대한 포괄적 이해를 보장하고 원래 의도의 모호성을 최소화합니다.

b. AI는 명확화된 의도를 사용자 스토리, 비기능 요구사항(NFR), 위험 설명으로 상세화합니다. 팀은 이러한 산출물을 검증하고 감독을 제공하며 AI가 필요한 수정을 합니다.

c. AI는 높은 응집도의 스토리를 유닛으로 그룹화합니다. 예: "사용자 데이터 수집", "추천 알고리즘 선택", "API 통합" 등.

d. 제품 소유자는 이러한 출력을 검증하고 필요에 따라 조정하여 유닛을 세련화합니다. 예: 제품 소유자는 사용자 데이터 수집에 프라이버시 준수 세부사항이 부족함을 발견하고 요구사항을 조정하여 GDPR 특정 고려사항을 포함합니다.

e. AI는 모듈의 PRFAQ(선택 사항)를 생성하여 비즈니스 의도, 기능, 기대 이익을 요약합니다.

f. 개발자와 제품 소유자는 PRFAQ와 관련 위험을 검증하여 전체 목표와의 정렬을 보장합니다.

### 2. 구축 단계

다음 항목들은 모브 프로그래밍과 모브 테스팅 의식에 초점을 맞춘 이 단계의 주요 활동을 개요합니다:

a. 개발자는 AI와 세션을 확립합니다. AI는 개발자에게 할당된 유닛에서 시작하도록 촉구합니다.

b. AI는 도메인 주도 설계 원칙을 사용하여 할당된 유닛의 핵심 비즈니스 로직을 모델링합니다. 예: "추천 알고리즘" 유닛에서 AI는 제품, 고객, 구매 이력 같은 관련 엔티티와 그들의 관계를 식별합니다.

c. 개발자는 도메인 모델을 검토하고 검증하며, 비즈니스 로직을 세련화하고 실제 시나리오와의 정렬을 보장합니다(예: 신규 고객의 구매 이력 부재를 어떻게 처리할지).

d. AI는 도메인 모델을 논리 설계로 변환하여 확장성과 내결함성 같은 NFR을 적용합니다. 예: AI는 아키텍처 패턴(예: 이벤트 주도 설계)과 기술(예: 서버리스 계산을 위한 AWS Lambda)을 권장합니다.

e. 개발자는 AI의 권장사항을 평가하고 트레이드오프를 승인하며 필요에 따라 추가 고려사항을 제안합니다(예: 확장성을 위해 Lambda를 수락하지만 더 빠른 쿼리 성능을 위해 스토리지를 DynamoDB로 변경).

f. AI는 각 유닛의 실행 가능 코드를 생성하고 논리 컴포넌트를 특정 AWS 서비스에 매핑합니다.

g. 또한 기능, 보안, 성능 테스트를 자동 생성합니다(예: "추천 알고리즘" 유닛에서 AI는 협업 필터링을 구현하는 코드를 생성하고 DynamoDB 데이터 소스와 통합합니다).

h. 개발자는 생성된 코드와 테스트 시나리오/케이스를 검토하고 품질과 준수를 보장하기 위해 필요에 따라 조정합니다.

**테스트 및 검증:**
a. AI는 모든 테스트(기능, 보안, 성능)를 실행하고 결과를 분석하며 문제를 강조합니다.
b. 실패한 테스트에 대한 수정을 제안합니다. 예: 더 나은 성능을 위해 쿼리 로직 최적화.
c. 개발자는 AI의 발견을 검증하고 수정을 승인하며 필요에 따라 테스트를 재실행합니다.

### 3. 운영 단계

**배포:**
a. AI는 모듈을 배포 유닛(예: 컨테이너 이미지, 서버리스 함수)으로 패키지화합니다.
b. 개발자는 배포 구성을 승인하고 스테이징 및 프로덕션 환경으로의 롤아웃을 시작합니다.

**관찰 가능성 및 모니터링:**
a. AI는 메트릭, 로그, 트레이스를 분석하여 이상을 식별하고 잠재적 SLA 위반을 예측합니다. 예: AI는 피크 사용 중 지연 스파이크를 감지하고 증가된 트래픽을 처리하기 위해 추천 엔진 확장을 제안합니다.
b. AI는 운영 문제에 대한 액션을 제안하기 위해 플레이북과 통합합니다. API 응답 시간이 저하되면 AI는 DynamoDB 처리량 증가 또는 API Gateway 트래픽 재균형을 권장합니다.
c. 개발자는 AI의 권장사항을 검증하고 완화 조치를 승인하며 해결 결과를 모니터링합니다.

---

## V. AI-DLC 실습: 브라운필드 개발

브라운필드란 새 기능 추가, 비기능 요구사항 최적화, 리팩토링이나 결함 수정을 포함한 기술 부채 수정 등 기존 시스템에 변경을 가하는 것을 말합니다. 이 맥락에서 제품 관리자가 기존 애플리케이션에 새 기능을 추가해야 하는 시나리오를 고려합니다.

### 1. 구상 단계
브라운필드에서의 구상 단계 활동은 그린필드와 동일합니다.

### 2. 구축 단계
a. AI는 코드를 더 높은 수준의 모델링 표현으로 승격시킵니다. 모델은 정적 모델(컴포넌트, 설명, 책임, 관계)과 동적 모델(컴포넌트가 가장 중요한 유스케이스를 실현하기 위해 어떻게 상호작용하는지)로 구성됩니다.

b. 개발자는 제품 관리자와 협력하여 AI가 역공학한 정적 및 동적 모델을 검토, 검증, 수정합니다.

c. 이러한 추가 단계로 구축 단계의 나머지는 그린필드 시나리오와 유사합니다.

### 3. 운영 단계
브라운필드에서의 운영 단계 활동은 그린필드와 동일합니다.

---

## VI. AI-DLC 도입

AI-DLC는 기존 애자일 방법론에서 크게 벗어나지 않으며, 더 쉬운 채택을 주요 성과로 설계되었습니다. 그럼에도 전통적 방법론을 장기간 실천해온 조직이나 자체 AI 네이티브 방법론 변형을 발명하는 과정에 있는 조직은 AI-DLC를 채택하기 위한 특정 전략이 필요합니다. 다음 두 가지 접근방식이 이를 촉진한다고 생각합니다:

### a. 실습을 통한 학습
AI-DLC는 실제로 그룹으로 실습할 수 있는 일련의 의식(모브 엘라보레이션, 모브 구축 등)입니다. 문서나 전통적 훈련을 통해 방법론을 배우는 것이 아니라, 실무자가 현재 해결하고 있는 여러 실제 시나리오에서 AI-DLC 가이드와 함께 의식을 실습함으로써 배웁니다. AWS 솔루션 아키텍트는 대규모 조직에서의 채택을 초대규모로 확장하기 위해 이 접근방식을 패키지화한 **AI-DLC 유니콘 짐(Unicorn Gym)**이라는 필드 오퍼링을 만들었습니다.

### b. 새로운 개발자 경험 도구에 AI-DLC 통합
고객은 SDLC를 가로질러 개발자에게 통합된 경험을 제공하는 자체 오케스트레이션 도구를 구축하고 있습니다(예: Cognizant의 FlowSource, Aspire의 CodeSpell, HCL의 AIForce 등). 이러한 도구에 AI-DLC를 통합함으로써 대규모 조직의 개발자는 중요한 채택 드라이브 없이 원활하게 AI-DLC를 실습할 수 있습니다.

---

## 부록 A: AI-DLC 실습을 위한 프롬프트

다음 지시사항은 AI-DLC를 실습하기 위해 AI와의 대화에 사용할 수 있습니다.

### 설정 프롬프트
```
오늘은 애플리케이션 구축에 작업합니다. 모든 프론트엔드와 백엔드 컴포넌트를 위한 프로젝트 폴더를 생성하세요. 모든 문서는 aidlc-docs 폴더에 저장됩니다. 세션 전체에서 먼저 작업을 계획하고 그 계획을 위한 md 파일을 생성하도록 요청하세요. 제가 승인한 후에만 작업을 진행할 수 있습니다. 이러한 계획은 항상 aidlc-docs/plans 폴더에 저장됩니다. md 형식으로 많은 종류의 문서를 생성합니다. 요구사항, 기능 변경 문서는 aidlc-docs/requirements 폴더에 저장됩니다. 사용자 스토리는 aidlc-docs/story-artifacts 폴더에 저장되어야 합니다. 아키텍처와 설계 문서는 aidlc-docs/design-artifacts 폴더에 저장되어야 합니다. 모든 지시사항은 순서대로 aidlc-docs/prompts.md 파일에 저장되어야 합니다. 이 지시사항의 이해를 확인하세요. 필요한 폴더와 파일이 아직 존재하지 않으면 저장을 위해 생성하세요.
```

### 구상 단계 - 사용자 스토리
```
당신의 역할: 전문 제품 관리자로서 다음 작업 섹션에서 언급된 시스템을 개발하기 위한 계약이 될 명확히 정의된 사용자 스토리를 생성하는 임무를 맡았습니다. 먼저 작업을 계획하고 각 단계에 체크박스가 있는 md 파일(user_stories_plan.md)에 단계를 작성하세요. 단계에서 제 명확화가 필요하면 확인을 위해 단계에 메모를 추가하세요. 중요한 결정을 스스로 내리지 마세요. 계획을 완료하면 제 검토와 승인을 요청하세요. 제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면 계획의 체크박스를 완료로 표시하세요.

당신의 작업: 여기에 설명된 고수준 요구사항에 대한 사용자 스토리를 구축하세요 << 제품 설명 >>
```

### 구상 단계 - 유닛
```
당신의 역할: 경험 많은 소프트웨어 아키텍트입니다. 아래 언급된 작업을 시작하기 전에 계획을 세우고 계획의 각 단계에 체크박스가 있는 units_plan.md 파일에 단계를 작성하세요. 단계에서 제 명확화가 필요하면 저와 상호작용하여 확인을 얻기 위해 단계에 추가하세요. 중요한 결정을 스스로 내리지 마세요. 계획을 생성하면 제 검토와 승인을 요청하세요. 제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면 계획의 체크박스를 완료로 표시하세요.

당신의 작업: 사용자 스토리 mvp_user_stories.md 파일을 참조하세요. 사용자 스토리를 독립적으로 구축할 수 있는 여러 유닛으로 그룹화하세요. 각 유닛에는 단일 팀이 구축할 수 있는 높은 응집도의 사용자 스토리가 포함됩니다. 유닛은 서로 느슨하게 결합됩니다. 각 유닛에 대해 각각의 사용자 스토리와 수용 기준을 design/ 폴더의 개별 md 파일에 작성하세요.
```

### 구축 단계 - 도메인(컴포넌트) 모델 생성
```
당신의 역할: 경험 많은 소프트웨어 엔지니어입니다. 아래 언급된 작업을 시작하기 전에 계획을 세우고 계획의 각 단계에 체크박스가 있는 design/component_model.md 파일에 단계를 작성하세요. 단계에서 제 명확화가 필요하면 저와 상호작용하여 확인을 얻기 위해 단계에 추가하세요. 중요한 결정을 스스로 내리지 마세요. 계획을 생성하면 제 검토와 승인을 요청하세요. 제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면 계획의 체크박스를 완료로 표시하세요.

당신의 작업: design/seo_optimization_unit.md 파일의 사용자 스토리를 참조하세요. 모든 사용자 스토리를 구현하기 위한 컴포넌트 모델을 설계하세요. 이 모델에는 모든 컴포넌트, 속성, 행동, 컴포넌트가 사용자 스토리를 구현하기 위해 어떻게 상호작용하는지가 포함되어야 합니다. 아직 코드를 생성하지 마세요. 컴포넌트 모델을 /design 폴더의 별도 md 파일에 작성하세요.
```

### 구축 단계 - 코드 생성
```
당신의 역할: 경험 많은 소프트웨어 엔지니어입니다. 아래 언급된 작업을 시작하기 전에 계획을 세우고 계획의 각 단계에 체크박스가 있는 md 파일에 단계를 작성하세요. 단계에서 제 명확화가 필요하면 저와 상호작용하여 확인을 얻기 위해 단계에 추가하세요. 중요한 결정을 스스로 내리지 마세요. 계획을 생성하면 제 검토와 승인을 요청하세요. 제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면 계획의 체크박스를 완료로 표시하세요.

작업: search_discovery/nlp_component.md 파일의 컴포넌트 설계를 참조하세요. 설계에 있는 자연어 처리(NLP) 컴포넌트의 매우 간단하고 직관적인 Python 구현을 생성하세요. processQuery(queryText) 메서드에는 쿼리 텍스트에서 엔티티를 추출하기 위해 amazon bedrock API를 사용하세요. 클래스를 각각 개별 파일로 생성하되 vocabMapper 디렉토리에 보관하세요.
```

### 구축 단계 - 아키텍처
```
당신의 역할: 경험 많은 클라우드 아키텍트입니다. 아래 언급된 작업을 시작하기 전에 계획을 세우고 계획의 각 단계에 체크박스가 있는 deployment_plan.md 파일에 단계를 작성하세요. 단계에서 제 명확화가 필요하면 저와 상호작용하여 확인을 얻기 위해 단계에 추가하세요. 중요한 결정을 스스로 내리지 마세요. 계획을 생성하면 제 검토와 승인을 요청하세요. 제 승인 후 동일한 계획을 한 번에 한 단계씩 실행할 수 있습니다. 각 단계를 완료하면 계획의 체크박스를 완료로 표시하세요.

작업: 컴포넌트 설계 모델 design/core_component_model.md, UNITS/ 폴더의 유닛, ARCHITECTURE/ 폴더의 클라우드 아키텍처, BACKEND/ 폴더의 백엔드 코드를 참조하세요. 다음을 완료하세요:
- [CloudFormation, CDK, Terraform]을 사용하여 AWS 클라우드에 백엔드를 배포하기 위한 엔드투엔드 계획을 생성하세요
- 배포 전제조건이 있으면 모두 문서화하세요

계획 승인 후:
- 깨끗하고 간단하며 설명 가능한 코딩 모범 사례를 따르세요
- 모든 출력 코드는 DEPLOYMENT/ 폴더에 저장하세요
- 검증 계획을 생성하고 검증 보고서를 생성하여 생성된 코드가 의도대로 작동하는지 검증하세요
- 검증 보고서를 검토하고 식별된 모든 문제를 수정하며 검증 보고서를 업데이트하세요
```

---

**문서 끝**